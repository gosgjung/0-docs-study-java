---
layout: default
title: Java 기본상식들
nav_order: 99
has_children: false
parent: Java Basic
# grand_parent: 
permalink: /docs/java-basic/java-common-sense-2023-03
---


# Java 기본상식 (2023.03)
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

<br>

### 참고자료
{: .fs-6 .fw-700 }
<br>
<br>

### final, finalize, finally
{: .fs-6 .fw-700 }

#### final 클래스란
{: .fs-5 .fw-700 }
상속을 금지시킨 클래스다.<br>
어떤 클래스를 다른 프로그래머가 상속 받아서 사용하는 것을 금지시키고자 할 때 사용<br>
보안상의 이유 때문에 사용한다.<br>
<br>

이론 적으로는 중요한 class 의 subclass 를 만들어서 subclass 로 하여금 시스템을 파괴할 수 있기 때문에 Java 시스템은 중요한 class 에 대해 final 로 선언하고 있다. 예를 들면 String 클래스를 예로 들 수 있다.<br>
<br>
final class 로 선언되면 상속받을 수 없기 때문에 당연히 내부의 모든 method 는 overriding(재정의)될 수 없다.<Br>
<br>
<br>
**Human.java**<br>

```java
public final class Human {
    public int age;
    
    public void setAge(int age){
        this.age = age;
    }
}
```

<br>



**Student.java**<br>

에러가 발생한다. (The type Student cannot subclass the final class Human)

```java
public class Student extends Human { // 컴파일 에러. Human 클래스는 final 로 선언되었다.
    public int num;
    
    public int getNum(){
        return num;
    }
}
```

<br>


#### final 메서드
{: .fs-5 .fw-700 }

오버라이딩을 금지시킨 메서드.
final 클래스가 아닌 일반 class 에서 특정 메서드만 오버라이딩 할 수 없게 하려는 경우 오버라이딩을 금지시키고자 하는 메서드에 final 키워드를 붙인다.
이렇게 하면 그 메서드는 오버라이딩이 불가능하다.<br>
final method 는 왜 사용할까?
부모 클래스에서 정의한 method 기능을 자식 클래스가 그대로 쓰게하고 싶을 때 사용한다.
예를 들어 부모 클래스에 입으로 말하는 것에 대해 정의된 speak() 메서드가 존재하는 경우를 생각해보자.
이때 상속받은 자식 클래스가 speak() 메서드를 재정의해서 손으로 말하도록 기능을 바꾸게 되는 경우도 있을 수 있다. 이런 것을 방지하고자 할 때 사용한다.<br>
<br>

e.g.
Human.java
```java
public class Human {
    public int age;
    
    public final void setAge(int age){
        this.age = age;
    }
}
```
<br>
<br>

Student.java
```java
public class extends Human {
    public final void setAge(int age){ // 여기서 에러가 난다. 위의 Human 클래스의 setAge 메서드가 final 메서드로 선언되었기 때문에 오버라이딩이 불가하다.
        
    }
}
```
<br>
<br>

#### 불변객체, final
{: .fs-5 .fw-700 }

불변객체는 객체가 생성된 이후로 내부의 상태가 변하지 않는 객체를 의미한다.
- 원시타입의 멤버필드의 경우 단순하게 final 키워드와 함께 선언하면, 불변타입으로 선언가능하다
- 다만, 참조 타입의 멤버필드가 선언되어 있을 경우 final 로 선언했다라도 추가적으로 작업을 해줘야 한다.
<br>
<br>

##### 참조타입을 불변객체로 만들기 위해 해주는 작업들
{: .fs-4 .fw-700 }
일반 객체 일 경우, 배열/List와 같은 타입일 경우 이렇게 두가지 경우로 나누어서 불변객체 처리를 해줄수 있다.

- 일반객체
- 배열/리스트 등의 자료구조
  - 조회시에는 쉽게 설명하면 값의 복사본을 생성해서 반환해야 한다.
  - 수정 시에는 파라미터로 전달된 전달된 배열/리스트의 각 요소 값을 복사한 새로운 값으로 멤버필드에 저장해준다.
  - 배열, 리스트의 경우 내부를 복사해서 전달하는 이런 방식을 **방어적 복사(defensive-copy)**라고 한다.
<br>

참조변수가 일반객체일 경우
- 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 한다.
<br>
참조 변수가 배열/리스트 등의 자료구조일 경우
- 배열 일 경우 배열을 받아서 copy 해서 저장하고, getter에서는 clone 메서드를 통해 반환하도록 해준다.
- 배열을 그대로 참조하거나 반환할 경우, 외부에서 내부 값을 변경할수 있다. 따라서 clone 을 통해 복사한 값을 반환해서 원본 값을 변경하지 못하게 해야 한다.
- 리스트일 경우에도 배열과 마찬가지로 생성시에 새로운 List 를 만들어 값을 복사하게끔 해줘야 한다.
<br>
<br>


##### 불변객체의 장점
{: .fs-4 .fw-700 }

Thread Safe
- 병렬 프로그래밍에 유용하고, 동기화를 고려하지 않아도 된다.
<br>

실패 원자적인 메서드를 만들수 있다.
- 실행 중에 예외가 발생해도 메서드 호출 전의 상태를 유지할 수 있기 때문에 예외가 발생하기 전의 상태로 다음 로직을 처리가능하다.
<br>

부수효과를 피해서 오류를 최소화할 수 있다.
- 부수효과: 
  - 변수의 값이 변하거나, 객체의 필드 값이 변경되는 것으로 인해 예외 또는 오류가 발생해서 실행이 중단되는 현상
<br>

메서드 호출 시 파라미터 값이 변하지 않는다는 것을 보장 가능
<br>

가비지 컬렉션 성능을 높일 수 있다.
- 가비지 컬렉터가 스캔하는 객체의 수가 줄어들기 때문에 GC 수행시 지연시간이 줄어든다.
- (아래 내용 참고)

##### 불변객체가 가비지컬렉션의 성능을 높일 수 있는 이유
{: .fs-4 .fw-700 }
참고자료 : [Java 불변 객체](https://velog.io/@bey1548/JAVA-%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4)
<br>

불변객체를 생성할 때 내부적으로 수행되는 작업은 이렇다. 

1\) 먼저 해당 타입의 객체를 생성한다. 

2\) 해당 타입에 대한 컨테이너 객체로 ImmutableHolder 객체를 생성한다. 이렇게 생성된 ImmutableHolder 객체를 보통 **컨테이너**라고 이야기한다.

3\) 이렇게 생성된 ImmutableHolder 컨테이너 객체는 항상 해당 타입에 대한 value 객체를 참조한다.
<br>

GC 수행시 가비지 컬렉터는 이렇게 생성된 컨테이너 하위의 불변객체들을 스킵한다. 해당 타입에 대한 ImmutableHolder 라는 불변 객체 컨테이너가 살아있다는 것은 결국 해당 불변 객체 컨테이너 내의 모든 객체들은 처음에 할당된 그 상태로 참조되고 있음을 보장한다는 것을 의미한다. 

가비지 컬렉터는 이런 불변객체에 대한 컨테이너 하위의 객체들은 스캐닝을 스킵하게 된다. 결국 불변객체를 사용하면 가비지 컬렉터가 스캔해야 하는 객체의 수가 줄어들게 된다. 따라서 GC가 수행되더라도 지연시간을 줄일 수 있다.<br>
<br>

이 때 GC 가 수행될때 가비지 컬렉터는 컨테이너 하위의 불변객체들은 skip 할 수 있도록 도와준다. 해당 불변 컨테이너 객체 (ImmutableHolder) 가 살아있다는 것은 하위의 객체들도 모두 처음에 할당된 그 상태로 참조되고 있다는 것을 의미하기에, 가비지 컬렉터는 이 컨테이너 하의의 불변객체들을 스캐닝을 덜 하고, skip 하게 된다.<br>

따라서, 불변객체를 사용하면 가비지컬렉터가 스캔해야 하는 객체의 수가 줄어서 스캔해야 하는 메모리의 영역과 빈도수도 줄어든다. 따라서 GC가 수행되어도 지연시간을 줄일 수 있다.<br>
<br>


#### 불변클래스
{: .fs-5 .fw-700 }

참고자료 : [Java 불변 객체](https://velog.io/@bey1548/JAVA-%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4)<br>


아래의 규칙에 따라 정의한 클래스를 **불변 클래스**라 한다.

- 클래스를 final 로 선언하라
- 클래스 내의 모든 변수를 private과 final 로 선언하라
- 객체를 생성하기 위한 생성자 또는 정적 팩토리 메서드를 추가하라
- 참조에 의한 변경가능성이 있는 경우 방어적 복사를 이용해 전달하라.

<br>

e.g. ImmutableClass.java
```java
public final class ImmutableClass{
    private final int age;
    private final String name;
    private final List<String> list;
    
    private ImmutableClass(int age, String name){
        this.age = age;
        this.name = name;
        this.list = new ArrayList<>();
    }
    
    public static ImmutableClass of(int age, String name){
        return new ImmutableClass(age, name);
    }
    
    public int getAge(){return age;}
    public String getName(){return name;}
    public List<String> getList() {
        return Collections.unmodifieableList(list);
    }
}
```

정적 팩토리 메서드
- 내부 생성자를 만드는 대신 객체의 생성을 위해 정적 팩토리 메서드를 정의했다.
- 또한 List와 같은 컬렉션 타입의 경우 list를 방어적 복사를 통해 제공했다.
<br>

기본생성자의 위험함 -> 기본생성자를 private으로 지정하고 정적 팩토리 메서드로 제공

- Java 는 생성자를 선언하지 않으면 기본 생성자가 자동으로 생성된다.
- 이 경우 다른 클래스에서 기본생성자를 자유롭게 호출가능하게 된다.
- 이런 경우에 대해 정적 팩토리 메서드를 통해 객체를 생성하도록 강제하면 좋다.
<br>

참조를 통해 변경이 가능한 경우 방어적 복사
- List와 같은 타입의 경우 객체 생성시 list 를 방어적 복사를 통해 생성
<br>


### 추상클래스, 인터페이스
{: .fs-6 .fw-700 }

... 정리 예정

### 클래스, 객체
{: .fs-5 .fw-700 }

#### 클래스 멤버 변수 초기화 순서
{: .fs-6 .fw-700 }
클래스 멤버 변수 초기화 순서에 대해 설명해주세요
1 ) static 변수 선언부
- 클래스 로드 시 static 필드 선언부가 가장 먼저 초기화 된다.
2 ) 필드 변수 선언부
- 객체가 생성시 생성자 영역 보다 먼저 초기화 된다.
3 ) 생성자 영역
- 객체 생성시 JVM이 내부적으로 생성자 영역을 locking 한다. (thread safe 영역)
<br>
<br>

#### Inner Class 란
{: .fs-6 .fw-700 }


#### Inner Class 의 장점
{: .fs-6 .fw-700 }


...


이 외에도 비공개 리포지터리에 정리해둔 것들이 꽤 많은데, 아침에 뭘 좀 하느라 시간을 너무 많이 썼다.
jekyll 이 갑자기 깨지는 것도 땅을 파는데에 한 몫거들었다.
빠르게 정리 예정!!!
정리할게 산더미다. 롬복 어떻게 쓰는게 좋다 등등 이런것도 많다.

휴... 퇴근해서 정리하던가 새벽에 정리하든 얼렁얼렁 정리해야겠다!!!

