---
layout: default
title: Item 51. 메서드 시그니처를 신중하게 설계하라
nav_order: 3
has_children: false
parent:  Ch08. 메서드
grand_parent: Effective Java
permalink: /docs/effective-java/chapter08/item51
layout: default
---



# Item 51. 메서드 시그니처를 신중하게 설계하라
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

<br>

### 참고자료
{: .fs-6 .fw-700 }

- [이펙티브 자바 3/E](http://www.yes24.com/Product/Goods/65551284)
- [Effective Java 한국어판 예제 깃헙](https://github.com/WegraLee)
- [조슈아 블로크 Effective Java 깃헙](https://github.com/jbloch/effective-java-3e-source-code/tree/master/src/effectivejava)
  <br>

<br>



### 메서드 이름을 신중히 짓자
{: .fs-6 .fw-700 }

- 표준 명명규칙(아이템 68)을 따르자.
- 자바 라이브러리 API 가이드 참조
  - ex) Collections, List, String, ArrayList, ... 
<br>
<br>

### 편의 메서드를 너무 많이 만들지 말자
{: .fs-6 .fw-700 }

모든 메서드는 각각 자신의 소임을 다해야 한다.

- 확신이 서지 않으면 만들지 마라
- 클래스, 인터페이스는 각 기능을 완벽히 수행하는 메서드로 제공해야 한다.
- 메서드가 너무 많으면 관리하기 쉽지 않다.
<br>
<br>

### 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다
{: .fs-6 .fw-700 }

> 참고) 아이템 64 - 객체는 인터페이스를 사용해 참조하라

#### 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다
{: .fs-5 .fw-700 }
매개 변수로 적합한 인터페이스가 있다면, 이것을 구현한 클래스보다는 그 인터페이스를 직접 사용하자.<br>

예를 들면, 어떤 메서드에 `HashMap` 을 곧바로 넘길 일은 전혀 없다. 그 대신 `Map` 을 사용해야 한다. 이렇게 하면 `HashMap`, `TreeMap` , `ConcurrentHashMap`, `TreeMap` 의 부분 맵 등 어떤 `Map` 구현체도 인수로 건네는 것이 가능해진다.<br>

자바 라이브러리에는 존재하지 않는 커스텀으로 재정의한 Map 구현체도 사용가능하다.<br>
<br>

#### 인터페이스 대신 구체 클래스를 매개변수로 사용하는 경우의 단점
{: .fs-5 .fw-700 }
- 클라이언트에게 특정 구현체만 사용하게끔 제한하는 꼴이다.
- 혹시라도 입력 데이터가 다른 형태로 존재한다면 명시한 특정 구현체의 객체로 옮겨담느라 비싼 복사 비용을 치러야 한다.<br>
<br>

### boolean 보다는 원소 2개 짜리 열거타입을 고려하자
{: .fs-6 .fw-700 }

책에서는 `boolean` 보다는 원소 2개짜리 열거타입이 더 낫다. 라고 언급하고 있다.<br>

열거 타입을 사용하면 코드를 읽고 쓰기가 더욱 쉬워진다. 예를 들면 아래는 화씨온도(Fahrenheit), 섭씨온도(Celsius)를 원소로 정의한 열거타입이다.<br>

```java
public enum TemperatureScale {FAHRENHEIT, CELSIUS}
```
<br>

온도계 클래스가 있다고 해보자. 온도계에서는 인스턴스를 생성하는 정적 팩터리 메서드 `newInstance(...)` 를 사용하기로 했지만, 매개변수로 뭘로 할 지는 아직 정하지 않았다.
- 이때 boolean 타입을 사용하면 이런 모양이 된다.
  -  `Thermometer.newInstance(true)` 
- 반면, enum 을 사용하면 아래와 같은 모양이 된다.
  - `Thermometer.newInstance(TemperatureScale.CELSIUS)`
<br>

이렇게 코드를 작성하면, 구문이 수행하는 동작을 명확하게 설명할 수 있다는 장점이 있다. 물론 모든 boolean 타입에 이렇게 사용하기보다는 true/false 로 리턴하는게 더 명확한 경우 역시 있다는 점도 염두에 두고 enum 을 사용하는 것이 더 좋을수도 있을 것 같다.<br>
<br>

### 매개변수 목록은 짧게 유지하라
{: .fs-6 .fw-700 }

- 4개 이하가 기억하기 어렵지 않다.
- 같은 타입의 매개변수 여러개가 연달아 나오는 경우가 특히 해롭다.
<br>

### 매개변수 짧게 하는 tip
{: .fs-6 .fw-700 }
> 내 의견이 아니다. 저자가 적어둔 의견이다. 쓰다보니 왠지 내가 내 느낌을 적은것 마냥되어서 코멘트를 남겨뒀다.
<br>

- 1 ) 여러 메서드로 쪼갠다
- 2 ) 매개변수 여러개를 묶어주는 도우미 클래스를 만들어 활용
- 여러 메서드로 쪼개기 + 매개변수 여러개를 묶어주는 도우미 클래스 사용
  -  `1)` 과 `2)` 를 혼합한 방식
  -  객체 생성에 사용한 빌더패턴을 메서드 호출에 응용한다.

#### 1 ) 여러 메서드로 쪼갠다
{: .fs-5 .fw-700 }

필요 메서드 단위로 따로 분리한 후에 여러 메서드로 쪼갠다.<br>

각 메서드 단위로 분리해서 매개변수를 분리하면, 잘못하면 메서드가 너무 많아질 수 있지만, 서로 의미/기능이 완전하게 분리된 각각의 메서드로 분리가 가능하다.<br>
<br>

**직교성을 높여준다.**<br>
`책에서는 직교성을 높여 메서드 수를 줄여주는 효과가 있다.` 라고 설명하고 있다.<br>
> 저자가 이야기하는 직교성이라는 것은 공통점이 없는 기능들이 잘 분리되어 있다는 의미다. <br>
> (수학에서의 직교는 어떤 두 벡터가 서로 직각을 이룰때, 두 벡터의 내적은 0인데, 이것은 두 벡터가 서로 영향을 전혀 주지 않는 다는 의미다.)<br>
<br>

**`java.util.List` 인터페이스**<br>

ex) 리스트에서 주어진 원소의 인덱스를 찾아야하는데, 지정된 범위의 부분리스트 에서의 인덱스를 찾는 경우<br>

이 기능을 하나의 메서드로 구현하려 할때 필요한 매개변수는 아래의 3가지다.

- 부분리스트의 시작
- 부분리스트의 끝
- 찾을 원소

<br>

List 인터페이스는 아래의 메서드들을 통해 기능을 두개로 분리해 제공하고 있는데, 깔끔하게 서로의 기능이 분리되어 독립적이다.

- subList 메서드
  - 부분 리스트를 반환한다.
- indexOf 메서드
  - 주어진 원소의 인덱스 위치를 알려주는 메서드

<br>

`subList` 메서드가 반환하는 부분 리스트 역시 `List` 타입이기에, `indexOf` 메서드로 처리를 수행하는 것이 가능하다.<br>
<br>

#### 2 ) 매개변수 여러 개를 묶어주는 도우미 클래스를 만들어 활용
{: .fs-5 .fw-700 }

일반적으로 도우미 클래스는 정적 멤버 클래스(아이템 24)로 둔다.<br>

도우미 클래스를 사용한다는 의미는 매개변수 여러 개를 필요한 기능 단위로 나누고, 나누어놓은 단위별로 클래스를 하나 만들어두는 것을 의미한다.<br>

이렇게 도우미 클래스를 사용하게 될때는, 되도록 정적 멤버 클래스로 두어 사용하는 것이 좋다.<br>

> 참고 : 아이템 24 - 멤버 클래스는 되도록 static 으로 만들라

**ex) 카드게임**<br>

예를 들어 카드게임을 클래스로 만든다고 해보자.<br>

메서드를 호출할 때 카드의 숫자(rank), 무늬(suit)를 뜻하는 두 매개변수를 항상 같은 순서로 전달하게 된다.<br>

이런 경우는 이 둘을 묶는 도우미 클래스를 하나 만들고, 도우미 클래스 하나로 매개변수를 주고 받으면 API는 물론 클래스 내부 구현 역시 깔끔해진다.<br>
<br>

#### 3 ) 여러 메서드로 쪼개기 + 도우미 클래스 활용
{: .fs-5 .fw-700 }

- 첫 번째로 언급한 여러 메서드로 쪼개기
- 두 번째로 언급한 매개변수 여러개를 묶어주는 도우미 클래스를 활용하기 

이 두 방식을 혼합한 방식이다.<br>
매개 변수가 많고, 그 중 일부는 생략해도 괜찮을 경우 도움이 되는 방식이다.<br>

대략적으로 설명해보면 아래와 같은 방식이다.<br>

- 모든 매개변수를 하나로 추상화한 객체를 정의
- 클라이언트 측에서 이 객체의 필드들은 빌더패턴을 통해 개별 주입
  - 또는 setter 를 통해 필요한 값을 설정
- 클라이언트 측에서는 `execute` 메서드를 호출해 매개변수들의 유효성을 검증

<br>
